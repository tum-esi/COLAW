# Location Proof System

Welcome to the implementation of Location Proof System (LPS) that leverages the V2X communication in Vehicular Ad-Hoc Networks (VANETs).
For the implementation of the LPS the open source framework [VEINS](https://veins.car2x.org/) together with the extension [Artery](https://github.com/riebl/artery)
was used. VEINS combines the event-based network simulator [OMNeT++](https://omnetpp.org/) together with the road traffic simulator [SUMO](https://sumo.dlr.de/index.html)
into a framework for testing vehicular networks and protocols. Artery is an extension that implements the European ETSI ITS-G5 standard protocols like GeoNetworking and
BTP. Artery comes with several examples that can further extended to implement ITS-G5 services through the Artery's middleware.


Our LPS was implemented as a ITS-G5 services that can be found under **src/application/ExampleService**. In the following the most important parts of the simulation framework
and the implemented LPS will be presented.

## Implemented scenarios

All OMNeT++ based simulations need an *&ast;.ini* that includes all relevant parameters for the conducted simulations. The *\[General\]* section defines generic
simulation parameters like the tested *network* the *sim-time-limit* etc.
Named configurations of the form *\[Config \<config_name\>\]* usually define the examined parameters like *txPower* or the *updateInterval* of the services.
In case a special configuration is selected when running the simulation, besides
the parameters in the *\[General\]* section the parameters of the corresponding
*\[Config ...\]* section are taken into consideration.

We tested four different scenarios that can be found under **scenarios/artery/omnetpp.ini**. The **No_Obstacles&ast;** scenarios assume that there are no disruptions like buildings in the tested environment. Their configuration file **config.xml** takes only the path loss of the message propagation into consideration. The **Obstacles&ast;** scenario and the corresponding **config_obstacles.xml** takes also the
[obstacles shadowing](https://veins.car2x.org/documentation/modules/#obstacles) into consideration. The **&ast;Night** scenarios take into
consideration that during non rush hours the total amount of vehicles on the street are less. For that a sumo-scenario with a smaller 
vehicle insertion rate was generated. The parameters **\*.DecisionLogic** and **\*.NeighboringWindow** are the parameters that were examined during the simulations.

## Scenario configuration

Depending on the selected OMNeT++ configuration selecting the configuration is
done in a different way. If OMNeT++ is configured with a GUI (Tkenv or Qtenv)
then the parameters can be selected from the GUI once the program is started.
Since batch runs (for going through the different parameter settings) cannot be
run with a GUI, we strongly suggest configuring OMNeT++ with Cmdenv. You can
[reconfigure OMNeT++](https://doc.omnetpp.org/omnetpp/InstallGuide.pdf) by
setting the parameters *WITH_TKENV* and *WITH_QTENV* in the *configure.user*
file to *no* and running `./configure` followed by `make cleanall` and `make`.
You can now change the configuration of your scenario by going to your build
directory (probably *build*) executing `ccmake .` and setting parameter
**RUN_FLAGS** to **-c \<config_name\>** (e.g. *-c No_Obstacles*).

## Running scenarios

You can run the scenario like it is suggested by Artery by calling the **run_example** target from Artery's root directory:

    cmake --build build --target run_example

## SUMO scenario

A list of existing scenarios that can be used inside the SUMO framework can be found
[here](https://sumo.dlr.de/docs/Data/Scenarios.html). We chose the Bologna scenario
since it is a small-scale scenario that is not associated with many simulation problems (e.g. disappearing cars) like other scenarios are. In order to sun a SUMO
a network file (*&ast;.net.xml*) and a route file (*&ast;.rou.xml*). We used the shipped
**pasubio.net.xml** network file and generated some random routes in order to conduc
our simulations faster, since the real trace file was much bigger than we expected.
Random route can be generated by leveraging the [randomTrips.py](https://sumo.dlr.de/docs/Tools/Trip.html) script:

    <SUMO_HOME>/tools/randomTrips.py -n pasubio.net.xml -p 4 --route-file pasubio.rou.xml --seed 123

The parameter -p defines the repetition rate of the cars and the -seed option can
be used in order to create repeatable pseudo-randomness. This parameter was modified to generate route with different vehicle insertion 
rates that correspond to the **&ast;Night** scenarios. For the **Obstacles\***
scenarios an additional polygon file (*&ast;.poly.xml*) must be provided. We
generated our polygon file **pasubio.poly.xml** with the [NETEDIT](https://sumo.dlr.de/docs/NETEDIT.html) tool. All used files are put together into a
*&ast;.sumo.cfg* file which can be passed to the *&ast;.ini* file of the simulation.

## Services

Services that should run on an ITS-G5 node can be passed to the node's middleware
through a *&ast;.xml* file. There the services and the ports that they should run on
are declared. Used services can be found in the **services.xml** file. The source code of these services can be found under the directory **src/artery/application**. In the following some important information about the services will be presented.

### Middleware
A nodes' middleware is responsible for passing information between the lower
transportation layers and informing the running ITS-G5 services that are running
on the node. Important parameters that have to be configured for the middleware
are the *updateInterval* which defines the frequency with which the services are
triggered as well as the service list (*&ast;.xml*) that the middleware should initiliaze and work with during the course of the simulation. Both parameters
are passed to the OMNeT++'s *Middleware.ned* file through the *omnetpp.ini*.

### CaService
The Cooperative Awareness service is responsible to transmit a CAM message
according to the ETSI standards whenever certain conditions are met. The
*checkTriggeringConditions* function is called from the Middleware every *updateInterval*. When a CAM message is received by a neighboring station the
service is updating the awareness entries in their local dynamic map (LDM).

### LocalDynamicMap (LDM)
The LDM is keeping track of an ITS station's neighbors. In a *std::map\<StationID, AwarenessEntry\>* the
most relevant CAM messages are stored by StationID (*updateAwareness*) and irrelevant CAM messages
are discarded (*dropExpired*). For our LPS a function *return_neighbors* was implemented that scans through
the map and return a list of the most recent StationIDs back to the *ExampleService*. The number of
StationIDs that are returned are given by *NeighboringWindow* and the decision about a neighbor's relevance
is made by comparing whether the expiry timestamp is bigger than the current simulation time + (*DecisionLogic*/100) * lifetime. In other words, the bigger the *DecisionLogic* parameter the more recent the map entries
have to be so that their expiry timestamp are relatively far into the future.

### ExampleService
The core functionality of the LPS is implemented on top of the ExampleService that was shipped with the Artery
framework. Whenever the middleware is triggering this service (*trigger*) the node is starting a location proof gathering
round. He does so by asking the LDM for a list of most recent neighbors (endorsers) that he is packing into a sample request message a broadcasting it to his surroundings. When trasmitting the request he is also starting
a timer to not wait indefinitely for responses.
Once a node is receiving a message from his neighbors (*indicate*) he is first checking what kind of message it is. In case it is a request message he is looking at the endorser list for his own StationID. If he cannot find himself in the list he is discarding the message since he has nothing to gain by participating in this location proof round. If the requestor has endorsed him he is checking whether or not he can find the requestor in his
own LDM. If yes, he is creating a response message in which he endorses the requestor and the other endorsers that he can locate in his LDM.
If the received message in a response message he is checking whether the response is for a location proof
generation round that he has started himself. If yes, he is storing the response until either the timer runs out
or he has received all the responses from all the neighbors that he has endorsed.
The *initialize* and *finish* function inform the simulation framework about the parameters that should be recorded. These parameters are later being used to analyze the protocol's performance

## Evaluating scenarios
Data generated from the simulation is automatically stored under the **results** directory. **results/README.md** 
